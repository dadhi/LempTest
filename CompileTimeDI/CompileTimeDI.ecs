compileTimeAndRuntime 
{
// <auto-generated />
//
// The code is auto-generated from the *.ecs file
// All changes done to this .cs file will be lost on the next generate
//
    using System;
    using System.Collections.Generic;
    using System.Linq.Expressions;
    namespace CompileTimeDI
    {
        public interface IResolver 
        {
            object Resolve(Type serviceType);
        }

        public partial class CompileTimeDI : IResolver
        {
            public Dictionary<Type, Expression<Func<IResolver, object>>> Factories;

            public this() 
            {
                Factories = new Dictionary<Type, Expression<Func<IResolver, object>>>();
            }

            public void Register<T>(Expression<Func<IResolver, object>> factory)
            {
                Factories.Add(typeof(T), factory);
            }

            public class Exception : InvalidOperationException 
            { 
                public this(string m) : base(m) {} 
            }

            public object Resolve(Type serviceType) 
            {
                var isGenerated = false;
                object service = null;
                TryResolveGenerated(serviceType, ref service, ref isGenerated);
                if (isGenerated) 
                    return service;

                if (Factories.TryGetValue(serviceType, out var facExpr))
                {
                    // todo: @feature insert caching of compiled delegate here
                    var fDelegate = facExpr.Compile();
                    return fDelegate(this);
                }

                throw new Exception($"Unable to resolve `${serviceType}`");
            }

            partial void TryResolveGenerated(Type serviceType, ref object service, ref bool isGenerated);
        }
    }
}

includeFile("ServiceRegistrations.ecs.include");
compileTime 
{
    // for extension methods
    using System.Linq;
    using Loyc.Syntax;

    var factories = ServiceRegistrations.CreateAndConfigure().Factories;

    var ecs = Loyc.Ecs.EcsLanguageService.Value;
    var getMethods = factories.Select((f, i) => quote {
        object $(LNode.Id(GetMethodName(f.Key, i)))(IResolver r) => 
            $(Parse(ExpressionToString(f.Value.Body)));
    });

    var usings = factories.Keys
        .Select(x => x.Namespace).Where(n => !string.IsNullOrEmpty(n)).Distinct()
        .Select(n => quote { 
            using $(Parse(n)); 
        });

    string GetMethodName(Type t, int i) => "Get_" + t.Name + "_" + i;

    // primitive implementation for demonstration purposes
    string ExpressionToString(Expression e) => e.ToString();

    // `;` is required at the end
    LNode Parse(string expr) => 
        ecs.ParseSingle(expr + ';', inputType: ParsingMode.Expressions); 
        //ecs.Parse(f.Value.Body.ToString() + ';'); // works too but requires spread `$(.. Parse(x))` because returns the node list
}

namespace CompileTimeDI
{
    precompute(usings);

    partial class CompileTimeDI
    {
        partial void TryResolveGenerated(Type serviceType, ref object service, ref bool isGenerated) 
        {
            precompute(factories.Select((f, i) => quote {
                if (serviceType == typeof($(LNode.Id(f.Key.Name))))
                {
                    service = $(LNode.Id(GetMethodName(f.Key, i)))(this);
                    isGenerated = true;
                    return;
                }
            }));
        }

        precompute(getMethods);
    }
}