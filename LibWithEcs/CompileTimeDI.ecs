compileTimeAndRuntime 
{
// <auto-generated />
//
// The code is auto-generated from the *.ecs file
// All changes done to .cs file will be lost on the next generate
//
    using System;
    using System.Collections.Generic;
    using System.Linq.Expressions;
    namespace LibWithEcs
    {
        public class A {} // todo: @test just for test here, move to another assembly 

        public interface IResolver 
        {
            object Resolve(Type serviceType);
        }

        public partial class CompileTimeDI : IResolver
        {
            public Dictionary<Type, Expression<Func<IResolver, object>>> Factories;

            public this() 
            {
                Factories = new Dictionary<Type, Expression<Func<IResolver, object>>>();
            }

            public void Register<T>(Expression<Func<IResolver, object>> factory)
            {
                Factories.Add(typeof(T), factory);
            }

            public class Exception : InvalidOperationException 
            { 
                public this(string m) : base(m) {} 
            }

            public object Resolve(Type serviceType) 
            {
                var isGenerated = false;
                object service = null;
                TryResolveGenerated(serviceType, ref service, ref isGenerated);
                if (isGenerated) 
                    return service;

                if (Factories.TryGetValue(serviceType, out var facExpr))
                {
                    // todo: @feature insert caching of compiled delegate here
                    var fDelegate = facExpr.Compile();
                    return fDelegate(this);
                }

                throw new Exception($"Unable to resolve `${serviceType}`");
            }

            partial void TryResolveGenerated(Type serviceType, ref object service, ref bool isGenerated);
        }
    }
}

includeFile("ServiceRegistrations.ecs.include");
compileTime 
{
    // for extension methods
    using System.Linq;
    using Loyc.Syntax;

    var factories = ServiceRegistrations.CreateAndConfigure().Factories;

    var ecs = Loyc.Ecs.EcsLanguageService.Value;
    var getMethods = factories.Select((f, i) => quote {
        object $(LNode.Id(GetMethodName(f.Key, i)))(IResolver r) => 
            $(ecs.ParseSingle(f.Value.Body.ToString() + ';', inputType: ParsingMode.Expressions));
            // $(..ecs.Parse(f.Value.Body.ToString() + ';')); // note: works too, the ';' at the end required for parser to make it a statement
    });

    string GetMethodName(Type t, int i) => "Get_" + t.Name + "_" + i;
}

namespace LibWithEcs
{
    partial class CompileTimeDI
    {
        partial void TryResolveGenerated(Type serviceType, ref object service, ref bool isGenerated) 
        {
            precompute(factories.Select((f, i) => quote {
                if (serviceType == $(ecs.ParseSingle("typeof(" + f.Key.Name + ");")))
                {
                    service = $(LNode.Id(GetMethodName(f.Key, i)))(this);
                    isGenerated = true;
                    return;
                }
            }));
        }

        precompute(getMethods);
    }

    public static class Resolver 
    {
        public static T Resolve<T>(this IResolver r) => (T)r.Resolve(typeof(T));
    }
}